<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>My three.js tests</title>
		<!-- favicon - https://favicon.io/favicon-generator/ -->
		<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
		<!-- JS and CSS -->
        <link rel="stylesheet" href="css/stylestests.css" />
		<script src="node_modules/three/build/three.js"></script>
		<script src="node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
		<script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
		<script src="node_modules/three/examples/js/loaders/FontLoader.js"></script>
		<script src="node_modules/three/examples/js/geometries/TextGeometry.js"></script>
		<script src="node_modules/three/examples/js/objects/Reflector.js"></script>
		<script src="node_modules/three/examples/js/objects/Sky.js"></script>
		<!-- script to get big files from Dropbox (see code below) instead of locally (Github max file size is 25MB) -->
		<!-- <script src="https://cdn.jsdelivr.net/npm/dropbox@10.34.0/dist/Dropbox-sdk.js"></script> -->
	</head>
	<body>
		<p><a href="index.html">Back home</a> <span style="margin-left: 100px;">Move skate with WASD or arrow keys!</span></p>
		<div id="three-container"></div>
		FOV: <input type="range" id="fov-slider" min="0" max="100" value="50" step="1">
		Camera X: <input type="range" id="camera-x-slider" min="-10" max="10" value="-2" step="0.1" autocomplete="off">
		Camera Y: <input type="range" id="camera-y-slider" min="-10" max="10" value="2" step="0.1" autocomplete="off">
		Camera Z: <input type="range" id="camera-z-slider" min="-10" max="10" value="5" step="0.1" autocomplete="off">
		<button id="reset-camera">Reset camera</button>
		<!-- <button id="auto-rotate">Auto rotate</button>
		Auto rotate speed: <input type="range" id="auto-rotate-speed" min="-10" max="10" value="2" step="1" autocomplete="off"> -->
		<button id="fixed-camera">Toggle fixed camera</button>
		<script>

			//			
			// SCENE SETUP
			//

			// Renderer
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth*.8, window.innerHeight*.8 );
			renderer.physicallyCorrectLights = true;
			document.querySelector('#three-container').appendChild( renderer.domElement );

			// Scene
			const scene = new THREE.Scene();
			scene.background = new THREE.Color('skyblue');
			
			// AxesHelper
			const axesHelper = new THREE.AxesHelper( 1000 );
			scene.add(axesHelper);

			// Camera -- initialize some values based on sliders' default values so we only need to change initial values in one place
			const camera = new THREE.PerspectiveCamera( document.querySelector('#fov-slider').value, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.x = document.querySelector('#camera-x-slider').value;
			camera.position.y = document.querySelector('#camera-y-slider').value;
			camera.position.z = document.querySelector('#camera-z-slider').value;
			// camera.lookAt(0,0,0);

			// Camera Helper (create a second camera to see all the lines) - for some reason can't move this second camera from 0,0,0
			// const camera2 = new THREE.PerspectiveCamera( 5, window.innerWidth / window.innerHeight, 5, 10 );
			// camera2.position.set(0,20,0);
			// const helper = new THREE.CameraHelper( camera2 );
			// scene.add( helper );

			// OrbitControls
			const controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.addEventListener('change', () => {
				// update sliders when the camera is moved with the OrbitControls (basically using the mouse)
				document.querySelector('#fov-slider').value = camera.fov;
				document.querySelector('#camera-x-slider').value = camera.position.x;
				document.querySelector('#camera-y-slider').value = camera.position.y;
				document.querySelector('#camera-z-slider').value = camera.position.z;
			});
			// controls.enableDamping = true;
			// controls.listenToKeyEvents(window);
			// controls.keyPanSpeed = 40;

			// Floor
			const textureLoader = new THREE.TextureLoader();
			const floorTexture = textureLoader.load( "img/tile_floor.jpg" );
			floorTexture.wrapS = THREE.RepeatWrapping;
			floorTexture.wrapT = THREE.RepeatWrapping;
			floorTexture.repeat.set( 400, 400 );
			const floorMaterial = new THREE.MeshStandardMaterial({map: floorTexture} );
			const floor = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), floorMaterial );
			floor.rotation.x = - Math.PI / 2;
			floor.position.y = 0;
			scene.add( floor );
			// Ground with helper grid - from https://threejs.org/examples/#webgl_animation_skinning_morph
			// const grid = new THREE.GridHelper( 100, 100, 0x000000, 0x000000 );
			// grid.material.opacity = 0.2;
			// grid.material.transparent = true;
			// grid.position.y = 0;
			// scene.add( grid );
			

			// Lights
			const directionalLight = new THREE.DirectionalLight('white', 3);
			directionalLight.position.set(100, 100, 100);
			scene.add(directionalLight);
			
			// const helper = new THREE.DirectionalLightHelper( directionalLight, 5 );
			// scene.add( helper );
			
			// const ambientLight = new THREE.AmbientLight( 0x404040, 3); // soft white light
			// scene.add( ambientLight );
		
			const hemiLight = new THREE.HemisphereLight(
				'white', // bright sky color
				'lightgrey', // dim ground color
				2, // intensity
			);
			scene.add( hemiLight );

			// Sky with sun - https://github.com/mrdoob/three.js/blob/master/examples/webgl_shaders_ocean.html and https://github.com/mrdoob/three.js/blob/master/examples/webgl_shaders_sky.html
			const sky = new THREE.Sky();
			sky.scale.setScalar( 10000 );
			sky.material.uniforms[ 'sunPosition' ].value = directionalLight.position;
			sky.material.uniforms[ 'rayleigh' ].value = 1;
			sky.material.uniforms[ 'turbidity' ].value = 5;
			sky.material.uniforms[ 'mieCoefficient' ].value = 0.01;
			sky.material.uniforms[ 'mieDirectionalG' ].value = 0.9;
			// renderer.toneMappingExposure = 0.01;
			scene.add( sky );



			//
			// OBJECTS
			//

			// Generic cube with custom texture
			const geometry = new THREE.BoxGeometry( 1, 1, 1 );
			const material = new THREE.MeshStandardMaterial( {
				emissiveIntensity: 0.5,
				map: textureLoader.load('img/harshbricks-Unreal-Engine/harshbricks-albedo.png'),
				aoMap: textureLoader.load('img/harshbricks-Unreal-Engine/harshbricks-ao2.png'),
				metalnessMap: textureLoader.load('img/harshbricks-Unreal-Engine/harshbricks-metalness.png'),
				normalMap: textureLoader.load('img/harshbricks-Unreal-Engine/harshbricks-normal.png'),
				roughnessMap: textureLoader.load('img/harshbricks-Unreal-Engine/harshbricks-roughness.png'),
			} );
			const cube = new THREE.Mesh( geometry, material );
			cube.position.z = 0;
			// scene.add(cube);

			// Generic spheres
			const sphereGeometry = new THREE.SphereGeometry(0.5);
			const sphereMaterial = new THREE.MeshStandardMaterial({color: 'olivedrab'});
			const sphereGroup = [];
			for (let i = 0; i < 10; i++) {
				sphereGroup[i] = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphereGroup[i].scale.multiplyScalar(Math.random()+0.3);
				sphereGroup[i].position.x = i*1.5;
				sphereGroup[i].position.y = 2;
				scene.add(sphereGroup[i]);
			}

			// geometric skateboard
			// const skate = new THREE.Mesh( new THREE.BoxGeometry( 2, 0.2, 0.5 ), new THREE.MeshStandardMaterial({color: 'maroon'}) );
			// scene.add(skate);
			// const wheelBack = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4), new THREE.MeshStandardMaterial({color: 'black'}));
			// wheelBack.rotation.x = Math.PI / 2;
			// wheelBack.position.x = 0.5;
			// wheelBack.position.y = -0.1;
			// const wheelFront = wheelBack.clone();
			// wheelFront.position.x = -0.5;
			// skate.add(wheelBack, wheelFront);
			// skate.position.y = 0.5;
			// skate.position.z = 1;


			// Mirror - view-source:https://threejs.org/examples/webgl_mirror.html
			const mirrorGeometry = new THREE.PlaneGeometry( 10, 10 );
			verticalMirror = new THREE.Reflector( mirrorGeometry, {
				clipBias: 0.003,
				textureWidth: window.innerWidth * window.devicePixelRatio,
				textureHeight: window.innerHeight * window.devicePixelRatio,
				color: 0x889999
			} );
			verticalMirror.position.y = 5;
			verticalMirror.position.z = -5;
			scene.add( verticalMirror );
			// const box = new THREE.BoxHelper( verticalMirror, 0xffff00 );
			// box.material = new THREE.LineBasicMaterial();
			// scene.add( box );

			// add a border around the mirror because the BoxHelper around the mirror is too thin
			let mirrorBorderTop = new THREE.Mesh( new THREE.BoxGeometry( 10, .1, .1 ), new THREE.MeshBasicMaterial( { color: "peru" } ) );
			mirrorBorderTop.position.y = 5;
			let mirrorBorderRight = new THREE.Mesh( new THREE.BoxGeometry( 10, .1, .1 ), new THREE.MeshBasicMaterial( { color: "peru" } ) );
			mirrorBorderRight.rotation.z = Math.PI / 2;
			mirrorBorderRight.position.x = 5;
			let mirrorBorderBottom = new THREE.Mesh( new THREE.BoxGeometry( 10, .1, .1 ), new THREE.MeshBasicMaterial( { color: "peru" } ) );
			mirrorBorderBottom.position.y = -5;
			let mirrorBorderLeft = new THREE.Mesh( new THREE.BoxGeometry( 10, .1, .1 ), new THREE.MeshBasicMaterial( { color: "peru" } ) );
			mirrorBorderLeft.rotation.z = Math.PI / 2;
			mirrorBorderLeft.position.x = -5;
			verticalMirror.add(mirrorBorderTop, mirrorBorderRight, mirrorBorderBottom, mirrorBorderLeft);

			
			// GLTFLoader for 3D models
			const loader = new THREE.GLTFLoader();
			let model, model2, model3, skateModel;
			let mixer;
			let fileLocation = 'img/OlmecHead.glb';

			// can also retrieve 3D model from dropbox instead of locally:
			// let fileLocation = 'https://dl.dropboxusercontent.com/s/6lv8fc5a6hkpoj5/Windmill%20Course%20Animation.glb?dl=0';

			// or, as the above (using the URL dl.dropboxusercontent.com to bypass CORS) is not fully supported (https://www.dropboxforum.com/t5/Dropbox-API-Support-Feedback/CORS-Access-Control-Allow-Origin/m-p/336138/highlight/true#M19583),
			// we can also use the code below (inspired by https://github.com/dropbox/dropbox-sdk-js/blob/main/examples/javascript/download/index.html)
			// note that we first need to generate an ACCESS_TOKEN from https://www.dropbox.com/developers/apps
			// THIS METHOD IS NOT SAFE FOR PRODUCTION - ACESS_TOKEN AND ACCESS TO MY OWN DROPBOX SHOULD BE KEPT PRIVATE
			// let fileLocation = '';
			// var dbx = new Dropbox.Dropbox({ accessToken: "ACCESS_TOKEN" });
			// await dbx.sharingGetSharedLinkFile({url: "https://www.dropbox.com/s/6lv8fc5a6hkpoj5/Windmill%20Course%20Animation.glb?dl=0"})
			// 	.then(function(data) {
			// 		console.log(data);
			// 		fileLocation = URL.createObjectURL(data.result.fileBlob);
			// 	})

			const clock = new THREE.Clock(); // clock for animation
			let textMesh = {}; // loading text to remove when windmill finishes loading
			loader.load( fileLocation, function ( gltf ) {
				// console.log(gltf);
				model = gltf.scene;
				model.position.x = 5;
				// add animations (when they exist in the source model - view-source:https://threejs.org/examples/webgl_loader_fbx.html
				// mixer = new THREE.AnimationMixer( model );
				// const action = mixer.clipAction( gltf.animations[ 0 ] );
				// action.play();
				scene.add( model );
				model2 = model.clone(); // create a few more models to populate the scene
				model3 = model.clone();
				model2.position.x = 8;
				model3.position.x = 12;
				scene.add( model2, model3 );
				scene.remove( textMesh );
			});

			loader.load( 'img/skateboard.glb', function ( gltf ) {
				// console.log(gltf);
				skateModel = gltf.scene;
				skateModel.scale.setScalar(0.3);
				skateModel.position.y = 0.2;
				scene.add( skateModel );
			});

			// Loading... text
			const fontLoader = new THREE.FontLoader();
			fontLoader.load( 'node_modules/three/examples/fonts/helvetiker_regular.typeface.json', function ( font ) {
				const textGeometry = new THREE.TextGeometry( 'Loading 3D models...', {
					font: font,
					size: 0.5,
					height: 0.2,
					curveSegments: 2
				} );
				var textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
				textMesh = new THREE.Mesh( textGeometry, textMaterial );
				textMesh.position.y = 1;
				textMesh.position.x = 3;
				scene.add( textMesh );
			});
			
			
			

			//
			// ANIMATIONS
			//

			// ball group
			let movementDirectionZ = new Array(10);
			let movementDirectionY = new Array(10);
			for (let i = 0; i < 10; i++) {
				movementDirectionZ[i] = true;
				movementDirectionY[i] = true;
			}

			// using threejs built-in animation system to animate one ball
			// https://discoverthreejs.com/book/first-steps/animation-system/
			const times = [0, 1, 2];
			const values = [0, 0, 0, 0, 2, 0, 0, 0, 0];
			const positionKF = new THREE.VectorKeyframeTrack(".position", times, values);
			const tracks = [positionKF];
			// use -1 to automatically calculate the length from the array of tracks
			const length = -1;
			const clip = new THREE.AnimationClip("slowmove", length, tracks);
			const ballMixer = new THREE.AnimationMixer(sphereGroup[0]);
			const action = ballMixer.clipAction(clip);
			action.play();

			let speed = 0;
			let fixedCamera = true;

			function animate() {
				requestAnimationFrame( animate );

				// cube.rotation.x += 0.01;
				// cube.rotation.y += 0.01;

				if(model)
					model.rotation.y += 0.01;
				if(model2)
					model2.rotation.x += 0.01;
				if(model3)
					model3.rotation.z += 0.01;
					
				for (let i = 1; i < 10; i++) {
					if(movementDirectionZ[i])
						sphereGroup[i].position.z += (i%3+3) * 0.01;
					else
						sphereGroup[i].position.z -= (i%3+3) * 0.01;
					if((sphereGroup[i].position.z >= 3) || (sphereGroup[i].position.z <= 0))
						movementDirectionZ[i] = !movementDirectionZ[i];
					if(movementDirectionY[i])
						sphereGroup[i].position.y += (i+1) * 0.01;
					else
						sphereGroup[i].position.y -= (i+1) * 0.01;
					if((sphereGroup[i].position.y >= 4) || (sphereGroup[i].position.y <= (0 + sphereGroup[i].geometry.parameters.radius/2)))
						movementDirectionY[i] = !movementDirectionY[i];
				}

				const delta = clock.getDelta();
				if ( mixer ) mixer.update( delta );
				if ( ballMixer ) ballMixer.update( delta );

				if(skateModel) {
					skateModel.position.z -= speed * Math.cos(skateModel.rotation.y);
					skateModel.position.x -= speed * Math.sin(skateModel.rotation.y);
					camera.lookAt(skateModel.position);
					controls.target = skateModel.position; // https://stackoverflow.com/a/68958468/3174659
					// move camera with object
					// https://discourse.threejs.org/t/how-do-i-make-camera-follow-an-object-regardless-of-the-x-y-and-z-rotation-of-the-object/28974/2
					// THIS CODE MAKES ORBITCONTROLS UNUSABLE, so we let user toggle between follow skate or orbit controls
					if(fixedCamera) {
						const cameraOffset = new THREE.Vector3(0.0, 5.0, 5.0); 
						camera.position.copy(skateModel.position).add(cameraOffset);
					}
				}
				
				controls.update();

				renderer.render( scene, camera );
			};

			animate();


			// Resize scene on window resize - https://discoverthreejs.com/book/first-steps/responsive-design/
			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth*.8, window.innerHeight*.8);
				renderer.setPixelRatio(window.devicePixelRatio);
			});
			
			// Sliders for user input
			document.querySelector('#fov-slider').addEventListener('input', function() {
				camera.fov = this.value;
				camera.updateProjectionMatrix();
				controls.update();
			});
			document.querySelector('#camera-x-slider').addEventListener('input', function() {
				camera.position.x = this.value;
				camera.updateProjectionMatrix();
				controls.update();
			});
			document.querySelector('#camera-y-slider').addEventListener('input', function() {
				camera.position.y = this.value;
				camera.updateProjectionMatrix();
				controls.update();
			});
			document.querySelector('#camera-z-slider').addEventListener('input', function() {
				camera.position.z = this.value;
				camera.updateProjectionMatrix();
				controls.update();
			});
			document.querySelector('#reset-camera').addEventListener('click', function() {
				controls.reset();
			});
			// document.querySelector('#auto-rotate').addEventListener('click', function() {
			// 	if(controls.autoRotate == false)
			// 		controls.autoRotate = true;
			// 	else
			// 		controls.autoRotate = false;
			// });
			// document.querySelector('#auto-rotate-speed').addEventListener('input', function() {
			// 	controls.autoRotateSpeed = this.value;
			// });
			document.querySelector('#fixed-camera').addEventListener('click', function() {
				fixedCamera == false ? fixedCamera = true : fixedCamera = false;
			});

			// move the skate with the arrow keys
			document.addEventListener('keydown', function(event) {
				const key = event.key; // "ArrowRight", "ArrowLeft", "ArrowUp", or "ArrowDown"
				
				if(key == "ArrowLeft" || key == "a" || key == "A") {
					skateModel.rotation.y += 0.1;
				} else if(key == "ArrowRight" || key == "d" || key == "D") {
					skateModel.rotation.y -= 0.1;
				} else if(key == "ArrowUp" || key == "w" || key == "W") {
					if(speed <= 0.1)
						speed += 0.005;
				} else if(key == "ArrowDown" || key == "s" || key == "S") {
					if(speed >= -0.1) 
						speed -= 0.005;
				}

			});

		</script>
	</body>
</html>